# 結束前言之前

{% hint style="info" %}
#### 小知識：編譯編譯器的編譯器

用C語言寫C語言的編譯器，這種自己編自己的狀況並不罕見。C以外的語言也有許多是以自己語言實作該語言本身。

如果X語言已經實作出之後，使用該語言本身製作新的X編譯器並沒有任何邏輯上的矛盾。想要達成 self-host 其實就只是用既有的編譯器（譯註：如 gcc、llvm）來進行開發，等到開發完成之後再改用自己來編譯就好了。本書所採用的也正是這種方法。

但是如果沒有既存的編譯器的話該怎麼辦呢？這種時候就非得用別的語言來寫了。如果想要達成X語言的 self-host，得先用Y語言來寫，等編譯器的完成度夠高的時候，再把編譯器從Y語言改用X語言開始整個重寫。

現代複雜的程式語言的編譯器也一樣，如果根據最初開發時使用的別的編譯器的族譜，一路追溯上去，最後應該會在早期的電腦上，發現某人用機械語言直接寫的組譯器（assembler）。從實作出現存所有語言的角度來說，那（些）組譯器可以說是終極的祖先。雖然不知道是單一還是有多個，但是現在的編譯器們確實是從這些少數的祖先衍生出來的，這是鐵打的事實。也因為編譯器以外的執行檔也都是由編譯器所編出，所以現有的所有執行檔，其實也是這些原始組譯器間接的子孫。這就像是生命的起源一樣，非常有意思。
{% endhint %}


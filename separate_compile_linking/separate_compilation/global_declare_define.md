# 全域變數的宣告與定義

雖然我們的編譯器來沒有全域變數，所以不會出現對應全域變數的組合語言指令作為範例，但是全域變數在組語階段和函式幾乎是一樣的。因此和函式一樣，全域變數也有分宣告和定義。所以如果變數本體出現在複數C程式檔中的話，通常會報連結錯誤。

全域變數預設是放在不可執行的記憶體區域內，所以要跳到該位址的話程式會發生記憶體區段錯誤（segment fault）然後崩潰（crash），但除此之外，資料和程式本質上是沒有不同的。執行時可以把函式作為資料像全域變數那樣讀取，也可以把記憶體的屬性改成可執行，跳躍到資料的位址，把資料作為程式執行。

函式和全域變數兩方本質上都只是記憶體裡的資料，我們實際用一段程式來確認看看吧。底下的程式是把`main`這個識別碼定義為全域變數。`main`的內容為x86\_64的機械碼：

```c
char main[] = "\x48\xc7\xc0\x2a\x00\x00\x00\xc3";
```

把上述的C程式碼存成 foo.c 後編譯，使用`objdump`確認看看其內容吧。`objdump`預設是顯示為16進制，加上`-D`參數就可以強制把檔案作為程式反組譯：

```text
$ gcc -c foo.c
$ objdump -D -M intel foo.o
Disassembly of section .data:

0000000000000000 <main>:
   0:   48 c7 c0 2a 00 00 00    mov    rax,0x2a
   7:   c3                      ret
```

預設把資料放在不可執行區域的作法，可以在編譯時加上`-Wl,--omagic`參數來變更。現在來使用這個參數生成可執行檔：

```text
gcc -static -Wl,--omagic -o foo foo.o
```




# 標頭檔的必要性與其內容

在分離編譯中，編譯器只看見程式的一部份程式碼，但編譯器並不能編譯任意部份的程式碼。舉例來說我們來考慮底下的程式碼：

```c
void print_bar(struct Foo *obj) {
  printf("%d\n", obj->bar);
}
```

上述的程式碼中，只要知道`Foo`的資料結構就能輸出對應這段程式碼的組合語言指令，但是不知道的話就無法編譯這個函式。

分離編譯時，需要把讓每一個C程式檔可以編譯的資訊，放進每一個檔案理。不過，如果把別的檔案的程式碼全部寫進去的話根本就不是分離編譯了，所以得做一定程度的資訊取捨。

舉個例子，我們來考慮要呼叫別的C檔案裡的函式需要什麼樣的資訊吧。編譯器需要以下的資訊：

* 首先，作為辨識碼，需要知道函式的名字這個資訊。
* 編譯器輸出呼叫函式的組合語言程式，必須把引數照規定的順序放到暫存器中，然後使用`call`指令跳到函式的開頭。引數根據型態不同可能會是整數或浮點數。並且引數的型態或數量不對的時候，必須要能顯示錯誤訊息。所以要知道函式的引數個數和各個引數的型態。
* 不管呼叫的函式做了什麼，對呼叫者來說就只知道其回傳，所以編譯時，呼叫者不需要知道被呼叫者的程式碼。
* `call`所要跳到的位址雖然在分離編譯時還不知道，但是可以在組合語言程式中總之先輸出跳到位址0的`call`指令，然後在目標檔中留下「目標檔的第X位元請修正為Y這個函式的位址」的資訊。連結器看到這個訊息，在執行檔佈局規劃好後，把程式的片斷接起來，然後修正跳躍的目的位址（這個步驟稱為「重新定位」（relocate））。因此，分離編譯需要知道函式的名字，但是不需要函式的位址。

綜上所述，只要省略函式本體的`{...}`，就有充份的資訊可以呼叫出該函式了。像這樣省去函式本體的就叫「宣告」（declaration）。宣告只告訴編譯器型態和名字，並不包含函式的程式碼。舉例來說底下就是`strncmp`的宣告：

```c
int strncmp(const char *s1, const char *s2, size_t n);
```

編譯器只要看到上面這1行，就能知道有strncmp的存在與其型態。反之，包含函式程式碼的就稱為「定義」（definition）。

在函式的宣告前，也可以加上代表宣告的關鍵字`extern`：

```c
extern int strncmp(const char *s1, const char *s2, size_t n);
```

但是函式的宣告，只要省略函式的本體就可以區分定義和宣告，所以不加上`extern`也沒問題。

此外，宣告中只要知道引數的型態就可以了，所以宣告中可以省略變數的名字，但是一般要讓人類容易理解所以就算是宣告通常也會寫上名字。


# 序

此線上電子書還在寫作中，仍未完成。[回饋給作者](https://goo.gl/forms/DWmgm5fChpJ6IEFI3)

對於想塞進一本書的分量來說，這本書所涵蓋的範圍是稍嫌貪心的。本書開發的是把C語言的程式碼轉（source code）換成組合語言（assembly code）用的程式，也就是所謂的C編譯器。而這個編譯器本身也是以C語言所開發。現階段的目標是Self-hosting－也就是自幹的編譯器要可以編譯其自己的程式碼。

本書為了避免解釋編譯器的難度突然上升太快，會以各式各樣的主題貫穿全書，漸漸加深難度的方式來進行。理由如下：

編譯器的概念可以分為幾個階段：語法分析、中途傳遞和產出指令。常見的教科書會以這些階段各自做為一個主題介紹，但是這樣的作法很容易在途中特定主題顯得過度深入，讓讀者難以跟上。

此外，分階段開發的作法在沒有完成所有階段之前，編譯器是沒辦法完整運作的，就算讀者的理解或是程式碼有關鍵的錯誤，很可能直到完整運作之前讀者都不會發現。而且說實話，對於下一個階段想要什麼樣的輸入，在自己開發到下一個階段之前其實也搞不太清楚，當然也就搞不太清楚前一個階段的輸出到底該怎麼樣才是對的。更何況在完成編譯器前都沒辦法編譯像樣的程式碼的狀況下，要如何維持開發的熱誠和動力也是一個困難的問題。

本書為了避開這種陷阱採用了不同的方針。在書的最開始，讓讀者實作語法非常單純的「自創語言」。因為該語言真的很單純，實作時並不需要了解編譯器的細節。之後，讀者在閱讀本書的過程中逐漸把功能實作到這個「原創語言」上，最後讓該語言成長到變得與C語言一致。

透過此種漸進式的開發方法，一邊提出一個一個小的commit，一步一步開發編譯器。在這個開發方法底下，每一個小的commit其實都是「完整的」編譯器。也就是說，在某個階段可能只是計算機等級的語言；某個階段可能是一個小範圍C語言的子集合；在某個階段可能就幾乎是完整的C語言了。關鍵在於，配合當時的完成度讓當時的語言有合理的結構，而不是在開發中只讓某部分的功能很突出、很像C語言。

其中所用到的資料結構與演算法、相關的基礎CS知識都會配合開發的進度逐步講解。






# 1973年的C編譯器

到現在為止，我們以逐步漸進的方式開發C編譯器。這樣的開發流程在某種意義上，可以說是走過了C語言的歷史。

看看現在的C語言，充滿了意義不清和過於複雜之處，這些部份如果跳脫歷史來看根本無法理解。現今C語言的難解之處，如果看看早期C的程式碼、了解早期C語言的樣子和後來語言與編譯器的發展，會覺得很多地方茅塞頓開。

C在1972年，為了Unix而開始開發。1972、1973年當時的，也就是C語言歷史中極早期的程式原始碼有留在磁帶裡，該檔案有被讀出並公開放在網路上。我們來看看[當時的C編譯器程式碼](https://github.com/qrush/unix/tree/master/src/c)吧。底下的程式碼，是`printf`格式中，接收訊息並編譯為錯誤訊息顯示的函式：

```c
error(s, p1, p2) {
  extern printf, line, fout, flush, putchar, nerror;
  int f;

  nerror++;
  flush();
  f = fout;
  fout = 1;
  printf("%d: ", line);
  printf(s, p1, p2);
  putchar('\n');
  fout = f;
}
```

有種難以言喻奇怪的感覺，看起來像C又不像C。當時的C就是這樣的語言。讀了這段程式碼後首先注意到的是：和我們做的早期編譯器一樣，函式的回傳值或引數是沒有型態的。這裡`s`是指向字串的指標、`p1`和`p2`為整數，但是當時的機器上它們全都是同樣的大小，所以變數像這樣是沒有型態的。

第2行中，`error`中寫了所指涉的全域變數和函式宣告。當時的C編譯器沒有標頭檔也沒有前處理器指令，所以程式設計師得像這樣告訴編譯器變數和函式的存在。

和現在我們的編譯器一樣，只確定函式名稱是否存在，並不會檢查引數的個數或型態是否正確。只要把預定數量的引數推進堆疊後，接著跳到函式本體後函式呼叫就算是成功了。

`fout`是持有輸出目標檔案描述子（file descriptor）的全域變數。在當時，還沒有`fprintf`，如果不是想要輸出到標準輸出（standard out，C語言中的`stdout`）而是想輸出到標準錯誤輸出（standard error，C語言中的`stderr`）的話，就得透過全域變數來切換輸出的目標。

`error`裡呼叫了2次`printf`。第2次的`printf`除了格式化的次串之外還傳了2個值。如此一來，在錯誤訊息只取第1個值時該怎麼辦呢？

其實這個error函式就算引數給少了，還是可以正常運作。回想一下，在當時並不存在函式的引數檢查。`s`、`p1`、`p2`這些引數只是單純從堆疊指標起算的第1、2、3個字組（word），實際上有沒有傳`p2`對應的值編譯器並不在意。而`printf`只會根據第1引數字串中的`%d`或`%s`的個數去存取引數，所以如果訊息只包含1個`%d`時，完全不會去存取`p2`。於是引數個數不一致也完全不會有問題。

早期的這種C編譯器，和現階段的9cc有許多類似之處。


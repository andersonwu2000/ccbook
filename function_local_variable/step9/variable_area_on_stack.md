# 堆疊上的變數空間

C的變數存在於記憶體中，也可以說，變數就是把記憶體位址取了名字而已。把記憶體位址取名之後，就可以不必講「存取記憶體的 0x6080 號位置」而是能以「存取變數 a」的方式來表現。

但是，每一次的函式呼，其區域變數都必須獨立存在。如果只考慮到實作的方便，舉例來說像「函式 f 的變數 a 放在 0x6080 號位置」這樣決定位址非常簡單，但是如果 f 是遞迴呼叫的話就無法正常運作。為了讓區域變數在每次函式呼叫可以獨立，C語言中變數會放在堆疊裡。

我們來以具體的例子想看看堆疊裡的內容。有1個函式 f 有 a 和 b 2個變數，假設有某個其他函式呼叫了 f。呼叫函式的`call`指令會把回傳位址推進堆疊，所以在 f 被呼叫的時間點的堆疊頂部，放的就是該回傳位址。除此之外，其他還有原本就放在堆疊裡的某些值，這些值具體是什麼在此處並不重要，我們以「......」表示。圖示如下：

| ...... |  |
| :---: | :--- |
| 回傳位址 | ← RSP |

此處以「← RSP」來表示現在 RSP 暫存器的值是指向該位址。a 和 b 的大小各為8 bytes。

堆疊成長的方向為向下成長。眼下要保留 a 和 b 的空間，得將 RSP 向下2個變數的份，總共加上16 bytes。執行之後會變成以下這樣：

| ...... |  |
| :---: | :--- |
| 回傳位址 |  |
| a |  |
| b | ← RSP |

如上分配完之後，用 RSP+8 的值就可以存取 a、用 RSP 的值就可以存取 b 了。像這樣在每次函式呼叫保留下來的記憶體空間，稱作「function frame」或「activation records」。（譯注：台灣較少使用這兩個名稱，可以搜尋「呼叫堆疊（call stack）」會比較容易找到相關資訊。）

其他函式看不到 RSP 的值要改多少 bytes、和要用什麼樣的順序去放變數，所以可以根據編譯器實作上的方便來自己決定作法。

區域變數的實作，基本上就是這麼單純。

但是，這個作法有一個缺點，所以實際實作的時候還會多用到一個暫存器。想想我們的編譯器（其他編譯器也一樣）在執行期間 RSP 會可能會改變這回事。9cc 在計算式子的過程中會使用 RSP 來推入／彈出堆疊，所以 RSP 的值其實變更地相當頻繁。因此，無法從 RSP 透過固定的 offset 去存取 a 或 b。


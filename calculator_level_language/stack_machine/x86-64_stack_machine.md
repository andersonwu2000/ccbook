# 以x86-64實作堆疊機的方法

目前為止討論的都是假想的堆疊機。真正的x86-64並不是堆疊機，而是暫存器機（register machine）。x86-64的運算多半是針對2個暫存器間定義的，並不是對堆疊頂端的2個元素定義。因此，想要把堆疊機的技巧用在x86-64上的話，就要用某些方法以暫存器機來模擬堆疊機才行。

用暫存器機來模擬堆疊機是相對簡單的。只要把堆疊機1個指令完成的動作用複數指令來實作就可以了。

接下來我們來說明怎麼做的具體方法：

首先，準備1個表示堆疊頂端的暫存器，這個暫存器稱為堆疊指標。如果想從堆疊取出2個值的話，就是從堆疊指標所指的位置取出2個元素，然後根據取出的要素數量去改編堆疊指標所指的位置。同理，推入堆疊時就是在寫入堆疊指標所指的記憶體的同時去改變其指標值。

x86-64的 RSP 暫存器就是以當作堆疊指標用而設計出來的。x86-64的`push`和`pop`指令默認會使用 RSP 暫存器作為堆疊指標，在改變 RSP 值的同時一邊讀寫 RSP 所指向的記憶體位置。於是，x86-64指令集要當成堆疊機使用的時候，用 RSP 暫存器會比較順利。我們就馬上來試試看把`1+2`這個算式用x86-64編譯成堆疊機指令吧。以下x86-64指令為編譯結果：

```text
// 把左邊和右邊推入
push 1
push 2

// 分別把左邊和右邊彈出到 RAX 和 RDI 然後相加
pop rdi
pop rax
add rax, rdi

// 把相加結果推到堆疊裡
push rax
```

x86-64沒有「把 RSP 所指的兩的元素相加」的指令，所以得先讀出來到暫存器中相加，再把計算的結果推回到堆疊裡。上述`add`指令做的就是這個動作。

同理，`2*3+4*5`用x86-64實作如下面的指令所示：

```text
// 計算2*3並把結果推入堆疊
push 2
push 3

pop rdi
pop rax
mul rax, rdi
push rax

// 計算4*5並把結果推進堆疊
push 4
push 5

pop rdi
pop rax
mul rax, rdi
push rax

// 把堆疊頂端的2個值相加
// 也就是計算2*3+4*5
pop rdi
pop rax
add rax, rdi
push rax
```


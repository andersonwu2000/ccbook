# 編譯成堆疊機指令

本節會說明把抽象語法樹轉成堆疊機程式的方法。如果做的到這點，我們就可以把四則運算的式子分析、建構抽象語法樹，編譯讓以x86-64語法建構的堆疊機可以執行的程式。也就是我們要可以寫出能編譯四則運算的編譯器了。



堆疊機在計算算式的一部份的時候，不論結果為何，作為結果的1個值將會留在堆疊的頂端。舉例來說考慮以下的樹：

![&#x8868;&#x793A;&#x52A0;&#x6CD5;&#x7684;&#x62BD;&#x8C61;&#x8A9E;&#x6CD5;&#x6A39;](../../.gitbook/assets/index%20%286%29.svg)

A和B是部份算式抽象化的表現，實際上是代表某種型態的結點。不過，該型態具體是什麼、樹的形狀如何，在編譯時並不重要。編譯此樹只要照著下面的步驟：

1. 編譯左邊的子樹
2. 編譯右邊的子樹
3. 輸出把堆疊上的2個元素相加，換成加法的結果的指令

執行1.的程式之後，不管該程式是什麼，堆疊頂端應該放著1個代表左邊子樹結果的值。同理，執行2.的程式之後，堆疊頂端應該放著1個代表右邊子樹結果的值。於是，要計算整個樹的值，就只要把這2個值相加，以合計的值取代就好了。

如此，把抽象語法樹編譯成堆疊機指令時，只要遞迴地思考，從樹的最下方逐步輸出組合語言指令就好了。對遞迴思考不習慣的讀者來說可能有點難，但是遞迴是處理樹結構時的基本。處理樹這樣子自己內部呈相似形的結構時，需要對部份和全體用同樣的方式對待，同樣的函式要可以用同樣的方法去處理全體、部份、甚至部份的部份。

我們用以下的範例來具體思考：

![&#x8868;&#x793A;&#x52A0;&#x6CD5;&#x548C;&#x4E58;&#x6CD5;&#x7684;&#x62BD;&#x8C61;&#x8A9E;&#x6CD5;&#x6A39;](../../.gitbook/assets/index%20%287%29.svg)




# 產生組合語言指令

在 x86-64 我們使用`cmp`指令來進行比較。從堆疊裡彈出2個整數進行比較，如果相同的話就在 RAX 設定1否則設為0，組合語言程式如下：

```text
pop rdi
pop rax
cmp rax, rdi
sete al
movzb rax, al
```

這段程式雖然短，但內涵有點豐富，我們來一步一步看下去：

開頭2行是把值從堆疊彈出。第3行是把他們進行比較（compare），但是比較的結果到哪裡去了呢？x86-64 會把比較指令的結果放到叫「狀態暫存器（FLAGS register）」的一個特別的地方。狀態暫存器是每當進行整數運算或比較就會更新的一個暫存器，其中有代表結果是否為0的位元、代表是否發生溢位（overflow）的位元、代表是否結果小於0的位元等等。

因為狀態暫存器並不是一般的整數暫存器，所以想要把比較的結果放到 RAX 的話，需要把狀態暫存器裡特定的位元複製到 RAX 上才行。這個指令就是`sete`，`sete`指令在前一個`cmp`指令的2個暫存器比較結果相同時，會把特定的暫存器（這裡為 AL）設成1，否則設為0。

AL 這個暫存器名在本書中至今為止是第一次登場，但其實 AL 只是代表 RAX 最後8位元的暫存器別名而已。所以，用`sete`設定 AL 的值時，RAX 也會自動更新。但是，透過 AL 更新 RAX 的話，首56位元的值並不會改變，所以要把 RAX 的值設為0或1的話，需要把首56位元清成0才行。為此我們使用`movzb`指令來達成。如果直接用`sete`直接寫進 RAX 就直接解決了，但是`sete`定義上只能存取8位元暫存器，所以比較的指令得像這樣用兩個指令來設定 RAX 的值才行。

![](../../.gitbook/assets/index%20%285%29.svg)

用其他指令取代`sete`就可以實作其他比較運算子。`<`用`setl`、`<=`用`setle`，`!=`則請使用`setne`來實作。

`>`和`>=`不需要指令產生器支援。請在分析器讀取時把左右換過來改成`<`和`<=`就可以了。

{% hint style="info" %}
#### 小知識：狀態暫存器與硬體
{% endhint %}

